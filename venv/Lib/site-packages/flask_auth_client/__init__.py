from typing import Tuple, Sequence, Callable, Optional, Dict, Any, NamedTuple
from enum import Enum
from functools import wraps
from fnmatch import fnmatch
from urllib.parse import urlencode

from flask import Flask, request, current_app, Response, redirect, render_template, g, Blueprint
import requests
import jwt


JWT_COOKIE = 'jwt'


class ApplicationType(Enum):
    SWAGGER_API = 0
    WEB_UI = 1


swagger_unauthenticated_routes = ('', '/swagger.json')

login_ui = Blueprint(
    'login_ui',
    __name__,
    template_folder='templates',
    static_folder='static'
)


class Identity(NamedTuple):
    username: str
    role: str


def load_public_key(auth_service_url: str):
    """Load the public key from the auth service"""
    if auth_service_url[0] == '/':
        # get public key from local file
        with open(auth_service_url, 'rb') as key_file:
            public_key = key_file.read()
    else:
        # request public key from remote service
        pub_key_url = auth_service_url.rstrip('/') + '/public-key'
        response = requests.get(pub_key_url)
        public_key = response.text
    return public_key


def login_redirect() -> Response:
    """Return a redirect to the login view"""
    url = "/login?" + urlencode({"referrer": request.url})
    return redirect(url, 302)


def access_denied_response() -> Response:
    """Send an access denied response if unauthenticated"""
    return Response(status=401, headers={'WWW-Authenticate': 'Bearer'})


def get_token() -> Optional[bytes]:
    """Get the raw JWT token from the request.
    Useful for forwarding the token to other services.
    """
    auth_token = get_token_from_header()
    if auth_token:
        return auth_token
    auth_token = get_token_from_cookie()
    if auth_token:
        return auth_token
    return None


def get_token_from_header():
    """Get JWT from Authorization header"""
    auth_header = request.headers.get("Authorization")
    if auth_header:
        auth_type, auth_token = auth_header.split()
        if auth_type == "Bearer":
            return auth_token
    return None


def get_token_from_cookie():
    """GET JWT from cookie"""
    auth_token = request.cookies.get(JWT_COOKIE)
    if auth_token:
        return auth_token
    return None


def get_token_from_basic_auth():
    """Request token from auth service using credentials from basic authentication

    This approach is provided to support legacy clients and is disabled by default
    """
    auth = request.authorization
    if not auth:
        return None
    current_app.logger.debug("User \"{}\" attempted login with basic authentication".format(auth.username))
    token = fetch_token(auth.username, auth.password)
    return token


def fetch_token(username, password):
    """Request a token from the auth service using a given username/password"""
    url = current_app.config["AUTH_SERVICE_URL"] + "/token"
    res = requests.post(url, data={"username": username, "password": password}, timeout=5)
    if res.status_code == 200:
        token = res.text
        return token
    return None


def decode_token(token: Optional[bytes], signing_algorithms: str) -> Optional[Dict[str, Any]]:
    if token:
        public_key = current_app.config["AUTH_PUB_KEY"]
        try:
            return jwt.decode(token, public_key, algorithms=signing_algorithms)
        except jwt.InvalidTokenError as e:
            current_app.logger.info(f'Authentication failed:\n{e}')
    return None


def get_current_identity():
    """Returns the current user's identity"""
    return g.identity


def check_roles(identity: Identity, authorized_roles: Optional[Tuple[str, ...]]) -> Optional[Response]:
    if authorized_roles and identity.role not in authorized_roles:
        current_app.logger.info(
            f'Denied user "{identity.username} - {identity.role}" access. Authorized roles: {authorized_roles}'
        )
        response = Response(status=403, content_type='text/plain')
        response.stream.write('You do not have permission access to this resource\n')
        return response
    return None


def make_auth_interceptor(redirect_routes: Sequence[str], unauthenticated_routes: Sequence[str],
                          signing_algorithms: str, redirect_all=False,
                          authorized_roles: Optional[Tuple[str, ...]]=None) -> Callable[[], Optional[Response]]:
    """Return a function to intercept all requests to the application and allow or deny access to the application"""

    def auth_interceptor():
        # Pre-flight requests made by the fetch API must always return 200
        if request.method == "OPTIONS":
            return None

        path = request.path.rstrip('/')
        for route in unauthenticated_routes:
            if path == route or fnmatch(path, route):
                return None

        deny_access_action = access_denied_response
        if redirect_all or path in redirect_routes:
            deny_access_action = login_redirect

        token = None

        if current_app.config["AUTH_BASIC"]:
            token = get_token_from_basic_auth()

        if not token:
            token = get_token()

        token_payload = decode_token(token, signing_algorithms)

        if token_payload is None:
            return deny_access_action()

        identity = Identity(username=token_payload['uid'], role=token_payload.get('role'))
        g.identity = identity

        return check_roles(identity, authorized_roles)

    return auth_interceptor


@login_ui.route('/', methods=["GET", "POST"], strict_slashes=False)
def login():
    """Render the login view or set the JWT token as a cookie and redirect to the originally
    requested view
    """
    if request.method == "GET":
        return render_template('login.html', auth_service_url=current_app.config['AUTH_SERVICE_URL'])
    elif request.method == "POST":
        token = request.form['token']
        redirect_url = request.form['redirect']
        response = redirect(redirect_url, 302)
        # Note: We're assuming the application hosting this defines the 'HTTPS' config key, default to True if not found
        response.set_cookie(JWT_COOKIE, token, secure=current_app.config.get('HTTPS', True), httponly=True)
        return response


@login_ui.route("/authenticate-url", methods=["GET"], strict_slashes=False)
def auth_url():
    """Return the URL to the auth service"""
    return current_app.config['AUTH_SERVICE_URL']


def authorize(roles: Optional[Tuple[str, ...]]=None):
    """Decorator to limit access by role for an individual view, also passes the identity object
    as the first argument to the function
    """
    def decorate(f):
        @wraps(f)
        def wrapper(*args, **kwargs):
            identity = getattr(g, 'identity', None)
            assert identity is not None, "No identity found for request"
            forbidden_response = check_roles(identity, roles)
            return forbidden_response if forbidden_response is not None else f(*args, **kwargs)
        return wrapper
    return decorate


def lockdown(app: Flask, app_type: ApplicationType, auth_service_url: str, signing_algorithms: str,
             unauthenticated_routes: Optional[Tuple[str, ...]]=None,
             authorized_roles: Optional[Tuple[str, ...]]=None, key_path: Optional[str]=None,
             swagger_ui_path: str='/ui', enable_basic_auth: Optional[bool]=False) -> None:
    app.config['AUTH_PUB_KEY'] = load_public_key(key_path or auth_service_url)
    app.config['AUTH_SERVICE_URL'] = auth_service_url.rstrip("/")
    app.config['AUTH_BASIC'] = enable_basic_auth

    app.register_blueprint(login_ui, url_prefix='/login')
    authentication_ui_routes = ('/login', '/login/static/login.js', '/login/authenticate-url')

    if unauthenticated_routes is None:
        unauthenticated_routes = tuple()

    if app_type == ApplicationType.SWAGGER_API:
        app.before_request(
            make_auth_interceptor(
                (swagger_ui_path,),
                swagger_unauthenticated_routes + unauthenticated_routes + authentication_ui_routes,
                signing_algorithms, authorized_roles=authorized_roles
            )
        )
    if app_type == ApplicationType.WEB_UI:
        app.before_request(
            make_auth_interceptor([], unauthenticated_routes + authentication_ui_routes,
                                  signing_algorithms, redirect_all=True,
                                  authorized_roles=authorized_roles)
        )
